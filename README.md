# 注意
由于作者使用的是MacOS，所以默认版本适用于Mac系统，其中“实验四win.cpp"为Windows版本，区别仅在于将system("clear"); 改为system("cls");

程序中进行Huffman Tree构建时使用了priority_queue优先队列进行自动排序，部分C++版本过低（比如学校电脑的Dev-C++）可能报错无法识别该类型，请更新C++版本后使用（注意不是更新Vscode等编辑器的版本，是C++编译器的版本，粗暴来讲重装C++）

# 实验关键点思路
就这个实验而言，难点在于想清楚树怎么构建，由于普通的树（第一问）并没有任何规律，只能老老实实自己一层一层用指针去连接。

相比之下第二问的可操作性就大很多，我个人认为按照题目意思想要进行加减公司的操作最好还是用完全二叉树的方式，而完全二叉树最好的存储结构就是顺序存储结构，所以直接把文件里的提取到线性表中就好，再通过角标之间的关系，遍历顺序表，给每一个结点添加上左右孩子指针

第二问的线索二叉树也比较有意思，由于普通的二叉树遍历采取递归结构，很难在递归遍历的过程中对每一个结点再进行判断能不能连线索。我这里采用的是把中序遍历的结果记录下来，然后看遍历这个结果，每一个结点的左右tag是什么情况，能不能连线索，如果能连线索就会非常方便，因为连接的地址就是中序遍历结果的前驱和后继。
当然这里很重要的一点就是在遍历的过程中，记录下来的一定要是结点的地址（也就是指针），拥有指针可以更改这个结点的所有东西，而只有这个结点对应的data则改变不了这个结点的指针变量。

与前两问不同，第三问Huffman Tree就具有很强的可编程性，知道每个字符的频率之后可以很方便的用循环构从下到上构造出一棵Huffman Tree。但是更大的困难其实在后面，首先Huffman Tree具有随机性，你并不知道你的电脑会给你造一个什么样子的树，所以怎么让程序自己找到每一个字符对应的编码就很关键，
我这里采用了和递归遍历类似的方式，注意到递归过程中，其实就是向左走或向右走的过程，所以向左走加一个0向右走加一个1时很自然的想法，但是这一想法并不容易实现，你如何保证递归过程中你的路径能存下来？如何保证递归到下一层的时候上面一层的code不能受影响（否则另一个分支就会出问题）。这里就需要灵活应用函数的传参过程是传递形参。
这里思路会比较绕，因为递归函数想要改变参数会对全局造成影响（改变函数参数类型数目，在内部调用的时候也要改），所以一般的递归函数都只传一个参，顶多共同作用与一个全局变量，然而这里的code即需要在某些时候被修改，又希望在下一层的时候不要修改上一层的code，所以我这里的处理方法是在传参的时候运用了字符串的加法，保证传进去的是添加了0或1的，而对该层的code不会有影响，读者可以根据程序自行理解一下，用言语有些难讲清楚。（程序中使用string s来记录code）

第三问还有一个开放性的思维点，在于发送报文的时候怎么把Huffman Tree传过去，传这棵树的方式可能有很多，我曾想过能不能把每一个字符的频率给传过去，但是由于构建Huffman Tree具有随机性，无法保证接收方构造出一样的Tree。这里才去了把每个字符的编码传过去的方式，
根据每个字符的编码，一次读取编码的每一位，其实就能构造出路径，对于构建过程，如果发现左或右无路可走，那么意味着需要加一个结点了，二最后一位一定指向了叶子结点，也就是包含字符信息的结点，这样就能很好的把Huffman Tree传递给接收方了。当然，读者可能有其他更优方式。（这里的传递全部按照老师要求，发送的过程相当于写入文件，接受的过程相当于打开文件，我这里分成了两个文件，避免在一个文件中难以分开树的信息和code的信息）

# 使用说明
## 推荐的使用方式
遇到想不清楚怎么做的部分，看一下我的代码是怎么处理的，然后自己写对应的思路，进行改进
## 不推荐的使用方式
将我的代码丢给各种AI，进行C++与C语言之间的多次翻译，然后对于翻译中丢失的功能再让AI补全
## 禁止的使用方式
直接把我的代码交给老师，或不加来源说明地使用
